"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useValidator = void 0;
var react_1 = require("react");
var form_1 = require("../form");
function formReducer(state, action) {
    var _a, _b, _c;
    switch (action.type) {
        case 'SET_VALUE':
            return __assign(__assign({}, state), { fields: __assign(__assign({}, state.fields), (_a = {}, _a[action.field] = __assign(__assign({}, state.fields[action.field]), { value: action.value }), _a)), pristine: false });
        case 'SET_TOUCHED':
            return __assign(__assign({}, state), { fields: __assign(__assign({}, state.fields), (_b = {}, _b[action.field] = __assign(__assign({}, state.fields[action.field]), { touched: true }), _b)) });
        case 'SET_ERROR':
            return __assign(__assign({}, state), { fields: __assign(__assign({}, state.fields), (_c = {}, _c[action.field] = __assign(__assign({}, state.fields[action.field]), { error: action.error }), _c)) });
        case 'RESET_FORM':
            var resetFields = {};
            for (var field in action.initialState) {
                resetFields[field] = {
                    value: action.initialState[field] || '',
                    touched: false,
                    error: undefined,
                };
            }
            return {
                fields: resetFields,
                validators: state.validators,
                pristine: true,
            };
        default:
            return state;
    }
}
function useValidator(initialState, _validators) {
    var context = (0, react_1.useContext)(form_1.FormContext);
    if (!context && context != null) {
        throw new Error("useFormContext must be used within a FormProvider");
    }
    var _a = (0, react_1.useReducer)(formReducer, {
        fields: Object.keys(initialState).reduce(function (acc, field) {
            acc[field] = {
                value: initialState[field] || '',
                touched: false,
                error: undefined,
            };
            return acc;
        }, {}),
        validators: _validators,
        pristine: true,
    }), formState = _a[0], dispatch = _a[1];
    var validateField = function (fieldName) {
        var fieldValidators = formState.validators[fieldName];
        var errors = [];
        if (fieldValidators && fieldValidators.length) {
            for (var _i = 0, fieldValidators_1 = fieldValidators; _i < fieldValidators_1.length; _i++) {
                var validatorFn = fieldValidators_1[_i];
                var error = validatorFn(formState.fields[fieldName] || {});
                if (error) {
                    errors.push(error);
                    break; // Stop validation on the first error found
                }
            }
        }
        dispatch({ type: 'SET_ERROR', field: fieldName, error: errors.length ? errors[0] : undefined });
    };
    var handleInputChange = function (fieldName, value) {
        dispatch({ type: 'SET_VALUE', field: fieldName, value: value });
        dispatch({ type: 'SET_TOUCHED', field: fieldName });
        validateField(fieldName);
    };
    var getFieldState = function (fieldName) {
        return formState.fields[fieldName];
    };
    var getErrorMessage = function (fieldName) {
        return formState.fields[fieldName].error;
    };
    var isFieldTouched = function (fieldName) {
        var _a;
        return (_a = formState.fields[fieldName]) === null || _a === void 0 ? void 0 : _a.touched;
    };
    var isFieldValid = function (fieldName) {
        var _a;
        return !((_a = formState.fields[fieldName]) === null || _a === void 0 ? void 0 : _a.error);
    };
    var isFormValid = function () {
        return Object.values(formState.fields).every(function (field) { return !field.error; });
    };
    var addValidator = function (fieldName, validator) {
        if (!formState.validators[fieldName]) {
            formState.validators[fieldName] = [];
        }
        formState.validators[fieldName].push(validator);
        validateField(fieldName);
    };
    var resetForm = function () {
        dispatch({ type: 'RESET_FORM', initialState: initialState });
    };
    return {
        formState: formState.fields,
        handleInputChange: handleInputChange,
        getErrorMessage: getErrorMessage,
        addValidator: addValidator,
        fieldState: function (fieldName) {
            var _a;
            return ({
                state: getFieldState(fieldName),
                value: ((_a = getFieldState(fieldName)) === null || _a === void 0 ? void 0 : _a.value) || '',
                valid: isFieldValid(fieldName),
                touched: isFieldTouched(fieldName),
            });
        },
        isFormValid: isFormValid,
        resetForm: resetForm,
    };
}
exports.useValidator = useValidator;
